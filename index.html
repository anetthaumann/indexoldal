<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Problémamegoldó szeminárium - feladatok</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      background-color: #f9fafb;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header { text-align: center; margin-top: 60px; margin-bottom: 40px; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    .meta { font-size: 1.05rem; color: #444; line-height: 1.4; }
    .buttons { display: flex; flex-wrap: wrap; gap: .75rem; margin-top: 1.5rem; justify-content: center; }
    .btn {
      background-color: #2563eb; color: #fff; padding: .75rem 1rem; border: none;
      border-radius: 10px; font-size: .95rem; cursor: pointer; transition: background-color .2s ease;
    }
    .btn:hover { background-color: #1d4ed8; }
    main { margin-top: 2rem; width: min(900px, 92%); min-height: 320px; text-align: center; color: #555; }

    
    .section { text-align: left; margin: 0 auto; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 1rem 1.2rem; margin: 1rem 0; background: #fff; }
    h2 { margin: 0.2rem 0 1rem; }
    h3 { margin: 0 0 .6rem; }
    pre { background: #f6f8fa; padding: .8rem; border-radius: 8px; overflow: auto; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .kv { color:#334155; }
    .badge { display:inline-block; font-size:.85rem; padding:.2rem .5rem; background:#eef2ff; border:1px solid #c7d2fe; border-radius:6px; }

    
    .table-examples{width:100%;border-collapse:collapse}
    .table-examples th,.table-examples td{border:1px solid #e5e7eb;padding:.6rem .8rem;vertical-align:top}
    .table-examples th{background:#f3f4f6;text-align:left}
    .table-examples pre{margin:0}
  
  footer {
  margin-top: 3rem;
  padding: 1rem 0;
  width: 100%;
  text-align: center;
  font-size: 0.9rem;
  color: #6b7280;
  border-top: 1px solid #e5e7eb;
}
  </style>
</head>
<body>
  <header>
    <h1>Problémamegoldó szeminárium – feladatok</h1>
    <div class="meta">
      <div><strong>Haumann Anett</strong></div>
      <div>Szegedi Tudományegyetem – TTIK</div>
      <div>2025–2026 őszi félév</div>
    </div>
    <div class="buttons">
      <button class="btn" onclick="showTask(1)">Első feladat (rekurzió) - A Recursive Function</button>
      <button class="btn" onclick="showTask(2)">Második feladat (dinamikus programozás) - A - Frog 1</button>
      <button class="btn" onclick="showTask(3)">Harmadik feladat (mohó stratégia) - Hit the lottery</button>
      <button class="btn" onclick="showTask(4)">Negyedik feladat (gráf) - Reachable Roads</button>
    </div>
  </header>

  <main id="content">
    <p>Nézd meg a feladatokat a gombok valamelyikére kattintva!</p>
  </main>

  <footer>
    <p>ChatGPT segítségével megvalósítva</p>
  </footer>

  <script>
    function showTask(num) {
      const content = document.getElementById('content');
      if (!content) return;

      const empty = (n) => `
        <div class="section">
          <h2>${n}. feladat</h2>
          <div class="card"><p>Folyamatban</p></div>
        </div>
      `;

      
      if (num === 1) {
        content.innerHTML = `
          <div class="section">
            <h2>1. feladat: <span class="kv">“A Recursive Function”</span></h2>

            <div class="card">
              <p><span class="badge">Forrás</span><br>
                AtCoder Beginner Contest 273 (2022. október 15.) –
                <a href="https://atcoder.jp/contests/abc273/tasks/abc273_a" target="_blank" rel="noopener">hivatalos feladatlink</a>
              </p>
            </div>

            <div class="card">
              <h3>Feladat leírása</h3>
              <p>Definiáljunk egy függvényt <code>f(x)</code>, amely nem negatív egész számokra van értelmezve, és a következőképpen van meghatározva:</p>

<ul>
  <li><code>f(0) = 1</code></li>
  <li><code>f(k) = k × f(k−1)</code>, ha <code>k</code> pozitív egész szám</li>
</ul>

<p>A feladat: adott egy egész szám <code>N</code> (<code>0 ≤ N ≤ 10</code>).  
Számítsd ki és írd ki <code>f(N)</code> értékét!</p>
            </div>

            <div class="card">
              <h3>Bemenet / Kimenet példák</h3>
              <table class="table-examples">
                <tr><th>Bemenet</th><th>Kimenet</th></tr>
                <tr><td><code>3</code></td><td><code>6</code></td></tr>
                <tr><td><code>0</code></td><td><code>1</code></td></tr>
                <tr><td><code>5</code></td><td><code>120</code></td></tr>
              </table>
            </div>

            <div class="card">
              <h3>Kész megoldás (Python)</h3>
              <pre><code>def f(n):
    if n == 0:
        return 1
    return n * f(n-1)

def main():
    n = int(input("Add meg N értékét (0–10 között): "))
    if n < 0 or n > 10:
        print("Hiba: N-nek 0 és 10 között kell lennie.")
        return
    print(f(n))

if __name__ == "__main__":
    main()</code></pre>
            </div>

            <div class="card">
            <h3>Magyarázat</h3>
            <p>A program egy matematikai függvényt számol ki, amit rekurzív módon definiálunk. Ez tulajdonképpen a faktoriális függvény:
            <code>f(0)=1</code>, és ha a szám nagyobb mint 0, akkor <code>f(k)=k×f(k−1)</code>.</p>

            <h4>Példa n = 4 esetén</h4>
            <ol>
              <li>f(4) → 4 × f(3)</li>
              <li>f(3) → 3 × f(2)</li>
              <li>f(2) → 2 × f(1)</li>
              <li>f(1) → 1 × f(0)</li>
              <li>f(0) = 1 → innen visszafelé számolunk</li>
            </ol>
          <p>Visszafelé haladva: f(1)=1, f(2)=2, f(3)=6, f(4)=24 → a program ezt írja ki.</p>

          <p>A program egy rekurzív függvényt valósít meg, ami önmagát hívja meg, amíg el nem éri a nullát. A nullánál megáll, és visszafelé kiszámolja az értéket. Ez tulajdonképpen a faktoriális, tehát 4 esetén 4×3×2×1=24.</p>

  <h4>Összefoglalva</h4>
  <ul>
    <li><b>Rekurzió:</b> a függvény önmagát hívja meg.</li>
    <li><b>Alapeset:</b> amikor n=0, ekkor a függvény megáll és 1-et ad vissza.</li>
    <li><b>Faktoriális:</b> n × (n−1) × (n−2) × … × 1.</li>
  </ul>
</div>
          </div>
        `;
        return;
      }

      
      if (num === 2) {
        content.innerHTML = `
          <div class="section">
            <h2>2. feladat: <span class="kv">"A - Frog 1”</span></h2>

            <div class="card">
              <p><span class="badge">Forrás</span><br>
                AtCoder Educational DP Contest (2019. január 6.) –
                <a href="https://atcoder.jp/contests/dp/tasks/dp_a" target="_blank" rel="noopener">hivatalos feladatlink</a>
              </p>
            </div>

            <div class="card">
  <h3>Feladat leírása</h3>
  <p>Adott <code>N</code> darab kő, amelyeket 1-től <code>N</code>-ig számoztunk. Minden kőhöz tartozik egy magasság, amelyeket <code>h<sub>1</sub>, h<sub>2</sub>, …, h<sub>N</sub></code> jelölnek.</p>
  <p>Egy béka kezdetben az első kövön áll, és az utolsó kőre szeretne eljutni. Minden lépésben a következőt teheti:</p>
  <ul>
    <li>Ha jelenleg az <code>i</code>. kövön áll, akkor ugorhat az <code>i+1</code>. vagy az <code>i+2</code>. kőre.</li>
    <li>Az ugrás költsége a két kő magasságkülönbségének abszolút értéke: <code>|h<sub>i</sub> - h<sub>j</sub>|</code>, ahol <code>j</code> az a kő, ahová ugrik.</li>
  </ul>
  <p>Határozd meg a lehető legkisebb összköltséget, amelyet a béka fizet, mire eléri az utolsó követ.</p>

<h4>Megkötések</h4>
  <ul>
    <li><code>2 ≤ N ≤ 10<sup>5</sup></code></li>
    <li><code>1 ≤ h<sub>i</sub> ≤ 10<sup>4</sup></code></li>
    <li>Minden bemeneti érték egész szám.</li>
  </ul>

  </div>

            <div class="card">
              <h3>Bemenet / Kimenet példák</h3>
              <table class="table-examples">
                <tr><th>Bemenet</th><th>Kimenet</th></tr>
                <tr>
                  <td><pre><code>4
10 30 40 20</code></pre></td>
                  <td><pre><code>30</code></pre></td>
                </tr>
                <tr>
                  <td><pre><code>2
10 10</code></pre></td>
                  <td><pre><code>0</code></pre></td>
                </tr>
                <tr>
                  <td><pre><code>6
30 10 60 10 60 50</code></pre></td>
                  <td><pre><code>40</code></pre></td>
                </tr>
              </table>
            </div>

            <div class="card">
              <h3>Kész megoldás (Python)</h3>
              <pre><code>

def main():
    
    N = int(input("Add meg a kövek számát (N): "))

    
    h = list(map(int, input(f"Add meg a {N} kő magasságait szóközzel elválasztva: ").split()))

    
    dp = [0] * N
    dp[0] = 0
    dp[1] = abs(h[1] - h[0])

    for i in range(2, N):
        dp[i] = min(dp[i-1] + abs(h[i] - h[i-1]),
                    dp[i-2] + abs(h[i] - h[i-2]))

    print("Minimális összköltség:", dp[-1])

if __name__ == "__main__":
    main()</code></pre>
            </div>

            <div class="card">
  <h3>Magyarázat</h3>

  <p><b>Mi a feladat lényege?</b> Az első kőről eljutni az utolsóra úgy, hogy a magasságkülönbségek miatti összköltség a lehető legkisebb legyen. Minden lépésben csak az előző (<code>i−1</code>) vagy az azelőtti (<code>i−2</code>) kőre ugorhatunk.</p>

  <h4>Dinamikus programozás</h4>
  <p>Hozzunk létre egy tömböt: <code>dp</code>. Ennek jelentése: <code>dp[i]</code> = a legkisebb összköltség, amellyel eljutunk az <code>i</code>. kőre.</p>
  <ul>
    <li><code>dp[0] = 0</code> – az első kövön kezdünk, költség nincs.</li>
    <li><code>dp[1] = |h[1] − h[0]|</code> – a második kőre csak az elsőről tudunk ugrani.</li>
  </ul>

  <h4>Általános lépés (a 3. kőtől kezdve)</h4>
  <p>Minden <code>i ≥ 2</code> esetén két lehetőségünk van, és a <b>olcsóbbat választjuk</b>:</p>
  <pre><code>dp[i] = min(
  dp[i−1] + |h[i] − h[i−1]|,   # egyet ugrunk
  dp[i−2] + |h[i] − h[i−2]|    # kettőt ugrunk
)</code></pre>

  <h4>Miért működik?</h4>
  <p>Mert az <code>i</code>. kőre érkezve tényleg csak két ésszerű előzmény van: az előző vagy az azelőtti kő. A legjobb (minimális) odaérési költséget ezekre már kiszámoltuk (<code>dp[i−1]</code>, <code>dp[i−2]</code>), így csak az adott ugrás árát kell hozzáadni, és választani a kisebbet.</p>

  <h4>Konkrét példa (N=4, h = [10, 30, 40, 20])</h4>
  <ul>
    <li><code>dp[0] = 0</code></li>
    <li><code>dp[1] = |30 − 10| = 20</code></li>
    <li><code>dp[2] = min( dp[1] + |40−30|,  dp[0] + |40−10| ) = min(20+10, 0+30) = 30</code></li>
    <li><code>dp[3] = min( dp[2] + |20−40|,  dp[1] + |20−30| ) = min(30+20, 20+10) = 30</code></li>
  </ul>
  <p><b>Eredmény:</b> <code>dp[3] = 30</code> – ez a minimális összköltség.</p>

  <h4>A kulcssor:</h4>
  <p>A "dp[i]" azt jelenti, mennyi a legkisebb költség az <code>i</code>. kőig. 
    A 3. kőtől mindig a két lehetséges előzményből választok: az előzőről vagy az azelőttiről ugrok, és a kettő közül a kisebbik összköltséget veszem.</p>
</div>
          </div>
        `;
        return;
      }

      
      if (num === 3) {
        content.innerHTML = `
          <div class="section">
            <h2>3. feladat: <span class="kv">“Hit the Lottery”</span></h2>

            <div class="card">
              <p><span class="badge">Forrás</span><br>
                Codeforces Problemset – 996A –
                <a href="https://codeforces.com/problemset/problem/996/A" target="_blank" rel="noopener">hivatalos feladatlink</a>
              </p>
            </div>

            <div class="card">
              <h3>Feladat leírása</h3>
              <p>Allen rengeteg pénzzel rendelkezik. A bankban <code>n</code> dollárja van. 
Biztonsági okokból készpénzben szeretné felvenni az összeget (az okokat most nem részletezzük).</p>

<p>A rendelkezésére álló bankjegyek címletei: <code>1</code>, <code>5</code>, <code>10</code>, <code>20</code> és <code>100</code> dollár.</p>

<p>Határozd meg, mi a <b>minimális bankjegyszám</b>, amellyel Allen pontosan <code>n</code> dollárt fel tud venni.</p>

<h4>Bemenet</h4>
<p>A bemenet egyetlen sora egy egész számot tartalmaz: <code>n</code> 
(<code>1 ≤ n ≤ 10<sup>9</sup></code>).</p>

<h4>Kimenet</h4>
<p>Írj ki egy egész számot — a minimálisan szükséges bankjegyek számát.</p>
            </div>

            <div class="card">
              <h3>Bemenet / Kimenet példák</h3>
              <table class="table-examples">
                <tr><th>Bemenet</th><th>Kimenet</th></tr>
  <tr><td><pre><code>125</code></pre></td><td><pre><code>3</code></pre></td></tr>
  <tr><td><pre><code>43</code></pre></td><td><pre><code>5</code></pre></td></tr>
  <tr><td><pre><code>1000000000</code></pre></td><td><pre><code>10000000</code></pre></td></tr>
              </table>
            </div>

            <div class="card">
              <h3>Kész megoldás (Python)</h3>
              <pre><code>def main():
    try:
        n = int(input("Add meg az összeget (1 ≤ n ≤ 1 000 000 000): "))
        if n &lt; 1 or n &gt; 10**9:
            print("Hiba: az összegnek 1 és 1 000 000 000 között kell lennie.")
            return

        notes = [100, 20, 10, 5, 1]
        cnt = 0

        for v in notes:
            cnt += n // v
            n %= v

        print(f"Minimálisan szükséges bankjegyek száma: {cnt}")

    except ValueError:
        print("Hiba: egész számot adj meg!")

if __name__ == "__main__":
    main()</code></pre>
            </div>

            <div class="card">
  <h3>Magyarázat</h3>

  <p>A program kiszámolja, hogy egy adott összeget hány bankjegyből lehet kifizetni a lehető legkevesebb darabbal. 
  Mindig a legnagyobb címletet használja először – ez a <b>mohó algoritmus</b> elve.</p>

  <p>A <code>notes</code> listában szerepelnek a címletek: <code>[100, 20, 10, 5, 1]</code>. 
  A program minden címletre kiszámolja, hány darab fér bele (<code>n // v</code>), majd levonja a maradék összeget (<code>n %= v</code>).</p>

  <p>A végén kiírja, hány bankjegy kellett összesen.</p>

  <h4>Összefoglalva:</h4>
  <ul>
    <li><b>Módszer:</b> mohó stratégia – mindig a legnagyobb címletet választja először.</li>
    <li><b>Miért működik:</b> a címletek rendszere olyan, hogy ez mindig optimális megoldást ad.</li>
  </ul>
</div>
          </div>
        `;
        return;
      }

    
      if (num === 4) {
  content.innerHTML = `
    <div class="section">
      <h2>4. feladat – Gráf algoritmus: <span class="kv">Kattis “Reachable Roads”</span></h2>

      <div class="card">
        <p><span class="badge">Forrás</span><br>
          Kattis Online Judge –
          <a href="https://open.kattis.com/problems/reachableroads" target="_blank" rel="noopener">
            Reachable Roads – hivatalos feladatlink
          </a>
        </p>
      </div>

      <div class="card">
        <h3>Feladat leírása</h3>
        <p>Egy nagy földrengés és tűzvész után a város útjainak egy része megsemmisült vagy járhatatlanná vált.
        Emiatt a város egyes pontjai között már nem lehet közlekedni.</p>

        <p>A várostervezők szeretnék a közlekedést mielőbb helyreállítani, ezért az a céljuk, hogy
        <b>minél kevesebb új utat</b> építsenek ahhoz, hogy <b>minden pontból minden másik pont elérhető legyen</b>.</p>

        <p>Tegyük fel, hogy bármely két pont között az út megépítésének költsége ugyanakkora, és
        az utak <b>kétirányúak</b>.</p>

        <p>A feladatod: határozd meg, hogy <b>minimum hány új utat</b> kell építeni ahhoz,
        hogy a város úthálózata ismét teljesen összefüggő legyen, vagyis minden pontból el lehessen jutni minden másikba.</p>
      </div>

      <div class="card">
        <h3>Bemenet / Kimenet példák</h3>
        <table class="table-examples">
          <tr><th>Bemenet</th><th>Kimenet</th></tr>
          <tr>
            <td>
<pre><code>2
3 3
0 1
1 2
2 0
10 6
0 2
8 9
1 2
1 8
1 4
4 7</code></pre>
            </td>
            <td>
<pre><code>0
3</code></pre>
            </td>
          </tr>
        </table>
      </div>
    </div>
  `;
  return;
}
    }
  </script>
</body>
</html>